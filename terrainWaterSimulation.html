<html>
  <body oncontextmenu="return false;">

    <script src="threeJS/build/three.js"></script>
    <script type="text/javascript" src="perlin.js"></script>

      <script id="vertexShader" type="x-shader/x-vertex">
            
        #define PI 3.14159
 
        precision mediump float;
        precision mediump int;

        // comes with framework
        uniform mat4 modelViewMatrix; // optional
        uniform mat4 projectionMatrix; // optional

        // user defined uniforms, values are passed in runtime
        uniform float time;
        
        // user defined attributes
        attribute vec3 position;
        attribute vec4 color;
        attribute vec3 normal;

        // data to be passed to fragment shader
        varying vec3 vPosition;
        varying vec4 vColor;
		varying vec3 vNormal;
        
        void main() {
		  vNormal = normal;
          vec3 posTmp = position;

          // calcuate pixel position on screen and pass to fragment shader
          gl_Position = projectionMatrix * modelViewMatrix * vec4 (posTmp, 1.0);

          vPosition = position;
          vColor = color;
        }

        </script>
        
        <script id="fragmentShader" type="x-shader/x-fragment">
            
          precision mediump float;
          precision mediump int;

          uniform float terrainResolution;
		  uniform sampler2D grasTexture;
		  uniform sampler2D rockTexture;
		  uniform sampler2D waterLerpTexture;

          // input from vertex shader
          varying vec3 vPosition;
          varying vec4 vColor;
		  varying vec3 vNormal;
          
          void main() {
                vec2 uv = vec2(vPosition.x/terrainResolution,vPosition.z/terrainResolution);
				vec2 uvTexture = uv*vec2(10.0,10.0);
				vec4 gras = texture2D(grasTexture, vec2(mod(uvTexture.x,1.0),mod(uvTexture.y,1.0)));
				vec4 rock = texture2D(rockTexture, vec2(mod(uvTexture.x,1.0),mod(uvTexture.y,1.0)));
				
				float tangent = dot(vNormal, vec3(0.0,0.0,1.0));
				float terrainMix = smoothstep(0.2,0.8,tangent);
				float height = smoothstep(vPosition.y,vPosition.y+20.0, terrainResolution/2.0);
				vec4 terrainTexture = mix(rock,gras, terrainMix*height);
				vec2 uvWater = vec2(uv.x, 1.0-uv.y);
				uvWater = vec2(mod(uvWater.x,1.0),mod(uvWater.y,1.0));
				float waterLerpTextureColor = 1.0-texture2D(waterLerpTexture, uvWater).r;
				vec4 terrainWithWater = mix(vec4(0.0,0.0,1.0,1.0), terrainTexture, waterLerpTextureColor);
				float light = dot(vNormal, vec3(0.5,-0.5,0)) *0.5 + 0.5;
				
				gl_FragColor = vec4(terrainWithWater.rgb * light,1.0);
          }
		  

        </script>
        
    <script>
      
      
    // global variables
	var cnt = 0;
    var terrainResolution = 128;
    var frameCnt = 0;
	
	//terrain values
	var terrainSize = 50;
	var terrainMaxHeight = terrainResolution/3;
      
	var waterSource = [Math.floor(terrainResolution/2), Math.floor(terrainResolution/2)];
    var scene;
    var camera;
	var mesh;
	var renderer;
    var geometry;

    var modRange = 12;
    var modStrength = 10;
	
	var heightArray;
	var waterArray;
	var waterArray2;
	var waterHeightArray;
	var waterHeightArray2;
	
	var mousePressed = false;
	
	var waterQueue = [];
	
	var positions = new Float32Array (terrainResolution*terrainResolution*18);
	var colors    = new Float32Array (terrainResolution*terrainResolution*18);
	var normal    = new Float32Array (terrainResolution*terrainResolution*18);

    var helper;
    var container;

    var raycaster = new THREE.Raycaster();
    var mouse = new THREE.Vector2();
	var mouseMove = new THREE.Vector2();
	
	var waterRGBA;
	var waterTexture;
	
	var grasTextureFile = "https://raw.githubusercontent.com/TherezaSchmelter/GenerativeGestaltung/master/gras.jpg";//"gras.jpg";
	var rockTextureFile = "https://raw.githubusercontent.com/TherezaSchmelter/GenerativeGestaltung/master/rock.jpg"; //"rock.jpg";
	
	var addQuad = function (positions, x, z) {

		var quadID = x + z * terrainResolution;

        addVertex(quadID*6*3+0, x, heightArray[x][z], z);
        addVertex(quadID*6*3+3, x+1, heightArray[x+1][z+1], z+1);
        addVertex(quadID*6*3+6, x+1, heightArray[x+1][z], z);

        addVertex(quadID*6*3+9, x, heightArray[x][z], z);
        addVertex(quadID*6*3+12, x, heightArray[x][z+1], z+1);
        addVertex(quadID*6*3+15, x+1, heightArray[x+1][z+1], z+1);

        cnt += 1;
      }

    var addVertex = function (id, x, y, z){
        positions [id+0] = x;
        positions [id+1] = y;
        positions [id+2] = z;

        calculateNormal(id,x,y,z);
      }

    var calculateNormal = function(id, x, y, z){
        var newNormal = [0.0,0.0,0.0];
        var heightLeft = heightArray[x][z] - ((x == 0)? heightArray[x][z]: heightArray[x-1][z]);
        var heightRight = heightArray[x][z] - ((x == terrainResolution - 1)? heightArray[x][z]: heightArray[x+1][z]);
        var heightDown = heightArray[x][z] - ((z == 0)? heightArray[x][z]: heightArray[x][z-1]);
        var heightUp = heightArray[x][z] - ((z == terrainResolution - 1)? heightArray[x][z]:heightArray[x][z+1]);

        newNormal[0] = heightLeft - heightRight;
        newNormal[1] = heightDown - heightUp;
        newNormal[2] = 2.0;

        var normalizedNormal = normalize(newNormal);

        normal[id+0] = normalizedNormal[0];
        normal[id+1] = normalizedNormal[1];
        normal[id+2] = normalizedNormal[2];
      }

    var normalize = function(vec){
        var length = Math.sqrt((vec[0]*vec[0]) + (vec[1]*vec[1]) + (vec[2] *vec[2]));
        vec[0] = vec[0]/length;
        vec[1] = vec[1]/length;
        vec[2] = vec[2]/length;
        return vec;
      }
	  
	var updateQuad = function (positions, x,y,z){
		var quadID = x + z * terrainResolution;
		
		positions [quadID*6*3+1] = heightArray[x][z];
        positions [quadID*6*3+4] = heightArray[x+1][z+1];
		positions [quadID*6*3+7] = heightArray[x+1][z];

		positions [quadID*6*3+10] = heightArray[x][z];
		positions [quadID*6*3+13] = heightArray[x][z+1];
		positions [quadID*6*3+16] = heightArray[x+1][z+1];
	}
	  
	function createTerrain(){

		THREE.ImageUtils.crossOrigin = '';
		generateHeight( terrainResolution, terrainResolution );
		createWaterLerpTexture();
		
        var material = new THREE.RawShaderMaterial( {
			uniforms: {
				time: { type: "f", value: 1.0 },
				terrainResolution: { type: "f", value: terrainResolution},
				grasTexture: { type: "t", value: THREE.ImageUtils.loadTexture(grasTextureFile)},
				rockTexture: { type: "t", value: THREE.ImageUtils.loadTexture(rockTextureFile)},
				waterLerpTexture: { type: "t", value: waterTexture}
			},

			vertexShader: document.getElementById ('vertexShader').textContent,
			fragmentShader: document.getElementById ('fragmentShader').textContent,
			side: THREE.FrontSide,
			transparent: true
        });
					
		geometry = new THREE.BufferGeometry();

        for (var i=0; i<terrainResolution-1; i++) {
            for (var j=0; j<terrainResolution-1; j++) {
                addQuad (positions, i, j);
            }
        }
        
        geometry.addAttribute ("position", new THREE.BufferAttribute (positions, 3));
        geometry.addAttribute ("color",    new THREE.BufferAttribute (colors, 3));
        geometry.addAttribute ("normal",   new THREE.BufferAttribute (normal, 3));
		
		mesh = new THREE.Mesh(geometry, material );
		
		return mesh;
	}
	
	function generateHeight( width, height ) {

		heightArray = new Array(width);
		waterArray = new Array(width);
		waterArray2 = new Array(width);
		waterHeightArray= new Array(width);
		waterHeightArray2= new Array(width);
		
		for (var i = 0; i < width; i++) {
			heightArray[i] = new Array(height);
			waterArray[i] = new Array(height);
			waterArray2[i] = new Array(height);
			waterHeightArray[i]= new Array(height);
			waterHeightArray2[i]= new Array(height);
		}
		
		var size = width * height; 
		//var data = new Uint8Array( size );
		var quality = 1.5;
		var z = Math.random() * 100;
		
		for( var a = 0; a < 4; a ++ ) {
			for ( var i = 0; i < width; i ++ ) {
				for ( var j = 0; j < height; j ++ ) {
				if(isNaN(heightArray[i][j])){ 
					heightArray[i][j] = 0;
				}
					heightArray[i][j] += (noise.simplex3(i/quality,j/quality,z)*0.5+0.5) * terrainMaxHeight * quality/100;
				}
			}
			quality *= 5;
		}
	}

	var simulateWater = function (){
		//heightArray
		//waterArray
		//waterHeightArray
		var simulate = waterQueue.length/3;
		console.log("length" + simulate);
		for(var i = 0; i < simulate && i < 1000*3; i++){
			var posx = waterQueue.shift();
			var posz = waterQueue.shift();
			var height = waterQueue.shift();
			simulateWaterPosition(posx,posz,height);
		}
		
		waterRGBA = new Uint8Array(4 * terrainResolution * terrainResolution);
		
		updateWaterLerpTexture();
    }
	
	var createWaterLerpTexture = function(){
		waterRGBA = new Uint8Array(4 * terrainResolution * terrainResolution);
		
		for ( var i = 0; i < terrainResolution; i ++ ) {
			for ( var j = 0; j < terrainResolution; j ++ ) {
				var id = i + j*terrainResolution;
				waterArray[i][j] = 0;
				waterHeightArray[i][j] = -100;
				
				waterRGBA[id*4 + 0] = i*2;
				waterRGBA[id*4 + 1] = j*2;
				waterRGBA[id*4 + 2] = 0;
				waterRGBA[id*4 + 3] = 255;
			}
		
		}
		
		waterTexture = new THREE.DataTexture( waterRGBA, terrainResolution, terrainResolution, THREE.RGBAFormat );
		waterTexture.needsUpdate = true;
	}
	
	var updateWaterLerpTexture = function(){
		for ( var i = 0; i < terrainResolution; i ++ ) {
			for ( var j = 0; j < terrainResolution; j ++ ) {
				var id = i + j*terrainResolution;
				if(waterArray[i][j] == 1){
					waterRGBA[id*4 + 0] = 255;
					waterRGBA[id*4 + 1] = 255;
					waterRGBA[id*4 + 2] = 255;
					waterRGBA[id*4 + 3] = 255;
				}else{
					waterRGBA[id*4 + 0] = 0;
					waterRGBA[id*4 + 1] = 0;
					waterRGBA[id*4 + 2] = 0;
					waterRGBA[id*4 + 3] = 255;
				}
			}
		}
		waterTexture = new THREE.DataTexture( waterRGBA, terrainResolution, terrainResolution, THREE.RGBAFormat );
		waterTexture.needsUpdate = true;
		mesh.material.uniforms.waterLerpTexture.value = waterTexture;
	}
	
	var simulateWaterPosition = function(x, y, height){
		
		var waterHeight = height;
		
		if(x + 1 <= terrainResolution -1 && heightArray[x+1][y] < waterHeight && waterArray[x+1][y] != 1){
			waterQueue.push(x+1);
			waterQueue.push(y); 
			waterQueue.push(heightArray[x+1][y]);
			waterArray[x+1][y] = 1;
		}
		if(x - 1 >= 0 && heightArray[x-1][y] < waterHeight && waterArray[x-1][y]!= 1){
			waterQueue.push(x-1); 
			waterQueue.push(y);
			waterQueue.push(heightArray[x-1][y]);
			waterArray[x-1][y] = 1;
		}
		if(y + 1 <= terrainResolution-1 && heightArray[x][y+1] < waterHeight&& waterArray[x][y+1]!= 1){
			waterQueue.push(x);
			waterQueue.push(y+1);
			waterQueue.push(heightArray[x][y+1]);
			waterArray[x][y+1] = 1;
		}
		if(y - 1 >= 0 && heightArray[x][y-1] < waterHeight&& waterArray[x][y-1] != 1){
			waterQueue.push(x);
			waterQueue.push(y-1);
			waterQueue.push(heightArray[x][y-1]);
			waterArray[x][y-1] = 1;
		}
	}
	

    var modifyTerrain = function (modifier, center){
      var startX = Math.floor(center.x) - modRange;
      var startY = Math.floor(center.y) - modRange;

      for (var i = startX; i < startX + modRange*2; i++) {
        for (var j = startY; j < startY + modRange*2; j++) {
          var distance = new THREE.Vector2(center.x, center.y).distanceTo(new THREE.Vector2(i,j));
          heightArray[i][j] += modifier * modStrength * Math.min(Math.max(Math.cos(distance/modRange * Math.PI/2),0),1);
        }
      }
      for (var i = startX-1; i < startX + modRange*2+1; i++) {
        for (var j = startY-1; j < startY + modRange*2+1; j++) {
          addQuad(positions, i, j);
        }
      }
      geometry.attributes.position.needsUpdate = true;
      geometry.attributes.normal.needsUpdate = true;
    }

    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera (70, window.innerWidth/window.innerHeight, 0.1, 50000);

	  camera.position.x = terrainResolution/2 + -100 * Math.sin(0);
      camera.position.z = terrainResolution/2 + -100 * Math.cos (0);
      camera.position.y = 200;
	  
	  console.log(camera.position.x + " " + camera.position.z);

      camera.lookAt (new THREE.Vector3 (terrainResolution/2,0,terrainResolution/2));
	  
      // default params
      renderer = new THREE.WebGLRenderer();
      renderer.setSize (window.innerWidth, window.innerHeight);
      document.body.appendChild (renderer.domElement);
      document.body.addEventListener( 'mousedown', onDocumentMouseDown, false );
	  document.body.addEventListener( 'mousemove', onMouseMove, false);
	  document.body.addEventListener( 'mouseup', onMouseUp, false);
      
      
      // create one mesh and add to scene
      mesh = createTerrain();
      scene.add(mesh);
	  
	  waterQueue.push(65);
	  waterQueue.push(65);
	  waterQueue.push( heightArray[65][65]);
	  waterArray[65][65] = 1;
    }

      // basic render loop
      var render = function () {
        
        frameCnt += 1;
		simulateWater();
        
        requestAnimationFrame (render);
        renderer.render (scene, camera);
      };

      // start
      init();
      render();


    function onDocumentMouseDown( event ) {
	
	  mousePressed = true;
      mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
      mouse.y = -( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);

      // See if the ray from the camera into the world hits one of our meshes
      var intersects = raycaster.intersectObject(mesh);

      // Toggle rotation bool for meshes that we clicked
      if (intersects.length > 0) {
        var modifier;
        if (event.button == 0){
          modifier = 1;
        }else{
          modifier = -1;
        }
        modifyTerrain(modifier,new THREE.Vector2(intersects[0].point.x, intersects[0].point.z));
      }
    }

    function onMouseMove( event ) {
		if(mousePressed){
			mouseMove.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
			mouseMove.y = -( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;
		
			var diff = mouseMove.x - mouse.x;
				
			mouse.x = mouseMove.x;
			mouse.y = mouseMove.y;
		}
    }
	
	function onMouseUp( event ) {
		mousePressed = false; 
    }

    </script>
  </body>
</html>
